'''
uc3m
Bachelor Thesis: Machine Learning-Based Predictive Modeling of Energy Prices
Author: Rodrigo De Lama Fern√°ndez
Professor: Emilio Parrado

File: new_ta_metrics.py
'''

import pandas as pd
import ta  # Technical Analysis Library
import numpy as np

# Load the data
    # the regular price data
data_path = 'data/processed_data.csv'
df = pd.read_csv(data_path, parse_dates=['Datetime'])

# Second run
    # the return data
# data_path = 'data/clean_return_data.csv'
# df = pd.read_csv(data_path, parse_dates=['Datetime'])

# Filter data for a specific hour (e.g., 14:00) to a new DataFrame (df_hour)
hour_to_predict = 14
df_hour = df[df['Datetime'].dt.hour == hour_to_predict].copy()


# Test with various rolling windows
# Rolling window
rw = 3

'''
- Simple Moving Average (SMA) (shorter window)
    A shorter SMA could be useful to identify short-term trends in energy prices. For example, a 5-day or 10-day
    SMA could help capture recent price movements

- Simple Moving Average (longer window)
    A longer SMA could be useful to capture long-term trends in energy prices. For example, a 50-day or 200-day
    SMA could help identify the overall direction of the market

- Exponential Moving Average (EMA): Similar to SMA but gives more weight to recent prices. This could be valuable
    to capture more immediate trends in energy prices

- Volatility ?
- Momentum ?

- Price Rate of Change (ROC)
	The ROC measures the percentage change between the current price and a price from a previous time period
    (e.g., 1 day, 7 days ago). It helps identify momentum in the market and is useful to highlight trends or
    sudden shifts in energy prices


- Relative Strength Index (RSI)
	A momentum indicator that can identify overbought or oversold conditions in the energy market. You can use
    it to track whether the price is approaching extreme values, which could indicate a reversal

    Is RSI really relevant ??
    In energy there is no such thing as overbought or oversold conditions, so idk if its actually useful
'''

# Simple Moving Average (SMA) (shorter window)
df_hour[f'SMA_{rw}'] = ta.trend.SMAIndicator(close=df_hour['MarginalES'], window=rw).sma_indicator()

# Simple Moving Average (longer window)
df_hour[f'SMA_{rw*10}'] = ta.trend.SMAIndicator(close=df_hour['MarginalES'], window=rw*10).sma_indicator()

# Exponential Moving Average (EMA)
df_hour[f'EMA_{rw}'] = ta.trend.EMAIndicator(close=df_hour['MarginalES'], window=rw).ema_indicator()

# Rate of Change (ROC, over N days)
df_hour[f'ROC_{rw}'] = ta.momentum.ROCIndicator(close=df_hour['MarginalES'], window=rw).roc()

#! Review if this is useful
# Relative Strength Index (RSI, N-day window)
df_hour[f'RSI_{rw}'] = ta.momentum.RSIIndicator(close=df_hour['MarginalES'], window=rw).rsi()

# Drop missing values generated by rolling calculations
df_hour.dropna(inplace=True)

# Check for NaN or infinity values
print("NaN values per column:\n", df_hour.isna().sum())
print("Infinity values per column:\n", df_hour.isin([np.inf, -np.inf]).sum())

# Drop NaN or infinity values
df_hour = df_hour.replace([np.inf, -np.inf], np.nan).dropna()
# Interpolate missing values
df_hour = df_hour.interpolate()

# Check for NaN or infinity values
print("NaN values per column:\n", df_hour.isna().sum())
print("Infinity values per column:\n", df_hour.isin([np.inf, -np.inf]).sum())


# Save the dataset with metrics for the selected hour
df_hour.to_csv(f'data/ta_metrics/metrics_hour_{hour_to_predict}_rw_{rw}.csv', index=False)

# Output message
print(f"Metrics for hour {hour_to_predict} calculated and saved to 'data/ta_metrics/metrics_hour_{hour_to_predict}_rw_{rw}.csv'.")
