import pandas as pd
import glob
import os

# Step 1: Set the path to the folder containing the files
file_path = '..data/2018/marginalpdbc_*.1'  # Update this to your actual folder path

# Step 2: Initialize an empty list to store DataFrames for each file
all_data = []

# Step 3: Loop through all files in the folder using glob
for file in glob.glob(file_path):
    # Extract the date from the filename (e.g., "marginalpdbc_20180105.1" -> "20180105")
    base_name = os.path.basename(file)
    file_date = base_name.split('_')[1].split('.')[0]
    
    # Convert the extracted date to Year, Month, Day
    year = int(file_date[:4])
    month = int(file_date[4:6])
    day = int(file_date[6:])
    
    # Step 4: Read the file into a DataFrame, assuming ';' is the separator
    daily_data = pd.read_csv(file, sep=';', header=None, encoding='utf-8')
    
    # Step 5: Assign appropriate column names
    daily_data.columns = ['MARGINALPDBC', 'Year', 'Month', 'Day', 'Hour', 'MarginalPT', 'MarginalES']
    
    # Step 6: Overwrite Year, Month, Day columns with the values from the filename
    daily_data['Year'] = year
    daily_data['Month'] = month
    daily_data['Day'] = day
    
    # Step 7: Append the daily DataFrame to the list
    all_data.append(daily_data)

# Step 8: Concatenate all the daily DataFrames into one big DataFrame
full_data = pd.concat(all_data, ignore_index=True)

# Step 9: Create a datetime column from Year, Month, Day, and Hour
# Adjust the 'Hour' column to deal with the potential 25th hour issue (e.g., setting 25th hour to 0 of the next day)
full_data['Hour'] = full_data['Hour'].apply(lambda x: 0 if x == 25 else x)
full_data['Datetime'] = pd.to_datetime(full_data[['Year', 'Month', 'Day', 'Hour']], errors='coerce')

# Step 10: Set the 'Datetime' column as the index for easier time-based filtering and operations
full_data.set_index('Datetime', inplace=True)

# Optional: Drop unnecessary columns like 'MARGINALPDBC'
full_data.drop(['MARGINALPDBC', 'Year', 'Month', 'Day', 'Hour'], axis=1, inplace=True)

# Step 11: Check the resulting DataFrame
print(full_data.head())